
* c++ specific
** sort 
- reverse sort
#+BEGIN_SRC C++
  std::sort(begin, end, std::greater<int>())
#+END_SRC
- sort custom struct
#+BEGIN_SRC C++
  struct Meeting{
      int start, end;
      int nth;
  };
  bool operator < (const Meeting& a, const Meeting& b){
      if (a.end != b.end) {
          return a.end < b.end;
      }    
      return a.start < a.start;
  } 
#+END_SRC
** priority_queue
#+BEGIN_SRC c++
  #include <queue>

  priority_queue<int> pq;
  priority_queue<int, vector<int>, greater<int>> pq_decreasing;
#+END_SRC
* algorithm
** max heap
properties: A[p]>=A[i], left = 2*i+1(0-based idx), right=2*i+2, parent = i/2
- maxHeapify(A, len, i) : LEFT(i) & RIGHT(i) already max heap. float down.
- buildMaxHeap : 
- heapSort : 

priorityqueue using max heap
- heapMaximum
- heapExtractMax
- heapIncreaseKey : 
- maxHeapInsert

** greedy
** graph
*** dfs
- topological sort : DAG(no cycle), see [[file:cpp/codejam/dictionary.cpp][dictionary]]
#+BEGIN_SRC c++

void toposort(){

}
#+END_SRC
* samsung strategy
- multiple category : for small N, choose brute force, for large N choose approximation algorithm like greedy.
  .e.g, category 1, N<10 , category 2 N<100, category 3, N<1000
* project G
** sort 
#+BEGIN_SRC java

  int partition(int[] a, int s, int e){
      p = a[e];
      i = s-1;
      for (int j = s; j <= e-1; j++){
          if (a[j]<=p){
              i++;
              swap(a[j], a[i]);
          }
      }
      swap(a[i+1], a[e]);
      return i+1;
  }
  // s,e : inclusive
  void qsort(int[] a, int s, int e){
      if (s<e){
          int m = partition(a, s, e);
          qsort(a, s, m-1);
          qsort(a, m+1, e);
      }
  }
  // sort custom object
  Arrays.sort(strings, new Comparator<String>(){
          int compare(String o1, String o2) {
              // return >0 , if o1 is greater than o2,
              // return 0, when equals
          }
      });
#+END_SRC
** binary search
#+BEGIN_SRC java
  static int binarySearch(int[] a, int s, int e, int key) {
      while (s <= e) {
          int m = (s + e) / 2;
          if (a[m] > key) {
              e = m - 1;
          } else if (a[m] < key) {
              s = m + 1;
          } else
              return m;
      }
      return -1;
  }
#+END_SRC
** questions
http://www.glassdoor.com/Interview/Google-Interview-Questions-E9079.htm
http://courses.csail.mit.edu/iap/interview/Hacking_a_Google_Interview_Practice_Questions_Person_B.pdf

bigo notation : http://bigocheatsheet.com/
http://www.reddit.com/search?q=google+interview+phone&restrict_sr=off&sort=relevance&t=all

*** kth largest element
quickselect
#+BEGIN_SRC c++
QuickSelect(A, k)
  let r be chosen uniformly at random in the range 1 to length(A)
  let pivot = A[r]
  let A1, A2 be new arrays
  # split into a pile A1 of small elements and A2 of big elements
  for i = 1 to n
    if A[i] < pivot then
      append A[i] to A1
    else if A[i] > pivot then
      append A[i] to A2
    else
      # do nothing
  end for
  if k <= length(A1):
    # it's in the pile of small elements
    return QuickSelect(A1, k)
  else if k > length(A) - length(A2)
    # it's in the pile of big elements
    return QuickSelect(A2, k - (length(A) - length(A2))
  else
    # it's equal to the pivot
    return pivot
#+END_SRC
*** pemutation, combination
    see [[file:cpp/codejam/combination.cpp][combination]]
** stack, queue
#+BEGIN_SRC java
  // queue
  LinkedList<Integer> l = new LinkedList<Integer>();
  l.poll();
  l.peek();
  l.add();

  // stack
  Stack<Integer> stack = new Stack<Intege>();
  stack.push(1);
  stack.pop();
#+END_SRC
** tree
#+BEGIN_SRC java
  int getMaxDepth(Node n){
      if(node==null)
          return 0;
      return 1 + Math.max(getMaxDepth(n.left), getMaxDepth(n.right));
  }

  Node getMinRecursive(Node n){
      if (n==null){
          return 987654321;
      }
      if (n.left!=null){
          return getMin(n.left);
      }
      return n;
  }

  Node getMinIterative(Node n){
      if (n==null){
          return 987654321;
      }
      Node cur = n;
      while(cur.left!=null)
          cur = cur.left;
      return cur;
  }
#+END_SRC
** math
- gcd
gcd(a,a) = a
gcd(a,b) = gcd(a - b,b), if a > b
gcd(a,b) = gcd(a, b-a)d, if b > a

** bit
#+BEGIN_SRC java
  int setBit(int n, int idx, boolean bset){
      if(bSet){
          return n | (1<<idx);
      }else{
          int mask = ~(1<<idx);
          return n & mask;
      }
  }
#+END_SRC
** CrackCode
- 1.6 NxN matrix, rotate 90 degree clockwise in-place
- 2.2 Implement an algorithm to find the nth to last element of a singly linked list. hint : using 2 node pointers
- 2.5 circular linked list. finding loop start. hint : using 2 node pointers
- 4.5 in-order successor
- 4.8 all path of tree which sum is S
- 11.1 stock price - system design
raw text files : hard to maintain
db : dynamic query, 
json file for each : simple enough to display static info



