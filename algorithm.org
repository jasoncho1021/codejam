
* c++ specific
** sort 
- reverse sort
#+BEGIN_SRC C++
  std::sort(begin, end, std::greater<int>())
#+END_SRC
- sort custom struct
#+BEGIN_SRC C++
  struct Meeting{
      int start, end;
      int nth;
  };
  bool operator < (const Meeting& a, const Meeting& b){
      if (a.end != b.end) {
          return a.end < b.end;
      }    
      return a.start < a.start;
  } 
#+END_SRC
- quick sort
#+BEGIN_SRC c++
void qsort(int* arr, int left, int right){
    int pivot = arr[(left+right)/2];
    int i=left, j=right;
    int tmp;

    while(i<=j){
        while(arr[i]<pivot)
            i++;
        while(arr[j]>pivot)
            j--;
        if (i<=j){
            tmp=arr[i];
            arr[i]=arr[j];
            arr[j]=tmp;
            i++;
            j--;
        }
    }

    if (left<j){
        qsort(arr, left, j);
    }
    if (right>i){
        qsort(arr, i, right);
    }
}
#+END_SRC
** priority_queue
#+BEGIN_SRC c++
  #include <queue>

  priority_queue<int> pq;
  priority_queue<int, vector<int>, greater<int>> pq_decreasing;
#+END_SRC
* algorithm
** max heap
properties: A[p]>=A[i], left = 2*i+1(0-based idx), right=2*i+2, parent = i/2
- maxHeapify(A, len, i) : LEFT(i) & RIGHT(i) already max heap. float down.
- buildMaxHeap : 
- heapSort : 

priorityqueue using max heap
- heapMaximum
- heapExtractMax
- heapIncreaseKey : 
- maxHeapInsert

** greedy
** graph
*** dfs
- topological sort : DAG(no cycle), see [[file:cpp/codejam/dictionary.cpp][dictionary]]
#+BEGIN_SRC c++

void toposort(){

}
#+END_SRC
* samsung strategy
- multiple category : for small N, choose brute force, for large N choose approximation algorithm like greedy.
  .e.g, category 1, N<10 , category 2 N<100, category 3, N<1000
* project G
** sort custom object
#+BEGIN_SRC java
  Arrays.sort(strings, new Comparator<String>(){
          int compare(String o1, String o2) {
              // return >0 , if o1 is greater than o2,
              // return 0, when equals
          }
      });
#+END_SRC
** behavoral questions
*** most challenging
Tizen/bada : 팀장 및 팀원들을 위키/cmake/CI를 사용하게 설득한 점. backward compatibility. bada 1.0 1.1 1.2
IE/CS SDK : global setting에 연관검색 관련 메뉴추가를 했는데/ 관련 지식이 없는 상태에서 몇일안에 셋팅에 추가해야 하는 일이 발생. 관련 지식이 없었기 때문에 해당 팀에 수소문 해서
 그분에게 도움을 요청. 전반적인 골격을 이해한 다음. 빌드/테스트 방법을 알아 추가 하는데 별탈 없이 잘 추가가 되었고. 이는 마지막 순간에 드롭이 되어 다시 빼야 했던일. 파생향등이 너무 많아
그것을 다 정리하는데 몇주가 소요 되었던 점.
*** what u learned 
IE/CS SDK : data의 중요성. privacy. service mind. 
Tizen/bada : 사람들을 설득 시키는 것의 어려움. 후발주자 플랫폼 프로바이더로서의 한계점. 
*** hardest bug
IE/CS SDK : global setting, html parsing(illegal syntax)
bada : vxworks target 에 포팅할때 int size가 2byte 였던 것으로 기억한다. 그래서 memcp 할때 메모리를 침범해서 정말 힘든 버그로 남았던 기억이 있다.

*** enjoyed most
Domino : 자발적으로 시작한 것이라 그런지 가장 많이 기억에 남는다. 4개월 동안 정말 게임 디자인/구현/서버/대기실/게임방 등을 모두 구현했고
프로그레스가 보이니 재미있기도 했다. 더구나 게임개발 부분 2위, 전체 3위의 성적을 받았기에 더욱더 기억에 남는다.
무언가에 같은 뜻을 가진 팀이 되어 도전한다는 것이 이렇게 재미날 수 있구나 하는 것을 느끼게 해준 프로젝트이다.
디자이너는 ppt로 모든 텍스쳐 작업을 했다. 군대의 힘이란 대단했다. 
Mobile Secondlife : connecting real/virtual world란 컨셉이 너무 멋있어서 한껏 고무되어서 했던것 같다. mixed contact, mixed chat이 너무 미래 지향적인것 같다. 
*** conflict with teammates
IE/CS SDK : 거의 모든 의사결정시 의견이 맞지 않는 팀원이 있어서 많은 스트레스를 받았던 적이 있다. module decomposition, policy, api param 이름 까지. 그 팀원은 항상 완벽주의를 추구했고
그렇게 하면 현실적으로 일정을 맞출수 없기도 하고 roi가 크지 않은 것들에 집착을 나타냈다. 심지어 여러 이해 당사자들과 이미 정리한 것들도 다시 얘기를 꺼내며 이렇게 해야 하지 않느냐고 말을 꺼내기도 했다.
그럴때 마다 약간 화가 나기도 했지만, 그 친구도 자신의 입장에서 최선을 다하려고 하는것은 알고 있었기에 나무랄 수만은 없었다. 그래서 그 친구 의도대로 완벽을 기할 수 있게 결정하고 진행할 수 있는 일들
위주로 주고 대신에 외국 연구소 인력을 몇 붙여 주었더니 자신의 철학대로 일도 진행하면서 나는 결과만 받고 그러니 일이 너무 잘 진행이 되는 것을 느낄 수 있었다.
Domino : 팀원 한명이 처음에는 잘 하다가 점점 참여도가 떨어졌다. 할일은 많은데 다른 팀원들도 불만이 생기기 시작했다.  어떻게 할까 하다가 결국엔 우리가 기여한 만큼 크레딧을 가지기로 했다. 
그러니 팀원들도 사람들도 수긍하는 눈치였고, 그 친구는 중간에 빠지면서 10%의 크레딧을 주장했고 우리는 인정해 주었다. 

** questions
http://www.glassdoor.com/Interview/Google-Interview-Questions-E9079.htm
http://courses.csail.mit.edu/iap/interview/Hacking_a_Google_Interview_Practice_Questions_Person_B.pdf

bigo notation : http://bigocheatsheet.com/
http://www.reddit.com/search?q=google+interview+phone&restrict_sr=off&sort=relevance&t=all

*** kth largest element
quickselect
#+BEGIN_SRC c++
QuickSelect(A, k)
  let r be chosen uniformly at random in the range 1 to length(A)
  let pivot = A[r]
  let A1, A2 be new arrays
  # split into a pile A1 of small elements and A2 of big elements
  for i = 1 to n
    if A[i] < pivot then
      append A[i] to A1
    else if A[i] > pivot then
      append A[i] to A2
    else
      # do nothing
  end for
  if k <= length(A1):
    # it's in the pile of small elements
    return QuickSelect(A1, k)
  else if k > length(A) - length(A2)
    # it's in the pile of big elements
    return QuickSelect(A2, k - (length(A) - length(A2))
  else
    # it's equal to the pivot
    return pivot
#+END_SRC
*** pemutation, combination
    see [[file:cpp/codejam/combination.cpp][combination]]
** tree
#+BEGIN_SRC java
  int getMaxDepth(Node n){
      if(node==null)
          return 0;
      return 1 + Math.max(getMaxDepth(n.left), getMaxDepth(n.right));
  }
#+END_SRC
** bit
#+BEGIN_SRC java
  int setBit(int n, int idx, boolean bset){
      if(bSet){
          return n | (1<<idx);
      }else{
          int mask = ~(1<<idx);
          return n & mask;
      }
  }
#+END_SRC
** CrackCode
- 1.6 NxN matrix, rotate 90 degree clockwise in-place
- 2.2 Implement an algorithm to find the nth to last element of a singly linked list. hint : using 2 node pointers
- 2.5 circular linked list. finding loop start. hint : using 2 node pointers
- 4.5 in-order successor
- 4.8 all path of tree which sum is S
- 


